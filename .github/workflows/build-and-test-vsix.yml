name: Build and Test VSIX Extension

on:
  push:
    branches: [ main, master ]
    paths:
      - 'oci-devops/**'
      - 'common/**'
      - '.github/workflows/build-and-test-vsix.yml'
  pull_request:
    branches: [ main, master ]
    paths:
      - 'oci-devops/**'
      - 'common/**'
      - '.github/workflows/build-and-test-vsix.yml'
  workflow_dispatch:

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # Required for committing and pushing VSIX file
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'

    - name: Cache node modules
      uses: actions/cache@v4
      with:
        path: |
          node_modules
          common/node_modules
          oci-devops/node_modules
        key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }}
        restore-keys: |
          ${{ runner.os }}-node-

    - name: Install dependencies
      run: |
        npm install
        cd common && npm install
        cd ../oci-devops && npm install

    - name: Build common package
      run: |
        cd common && npm run build

    - name: Build VSIX extension
      run: |
        cd oci-devops && npm run build
      continue-on-error: false

    - name: Verify VSIX was created
      run: |
        if [ ! -f oci-devops/oci-devops-*.vsix ]; then
          echo "Error: VSIX file was not created"
          exit 1
        fi
        ls -lh oci-devops/*.vsix
        echo "VSIX file created successfully"

    - name: Setup Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Test Docker build with Node.js Dockerfile
      run: |
        # Create a test Node.js project
        mkdir -p /tmp/test-nodejs-app
        cd /tmp/test-nodejs-app
        
        # Create a test package.json with invalid name (to test the fix)
        cat > package.json << 'EOF'
        {
          "name": "test api for cars",
          "version": "1.0.0",
          "description": "Test Node.js application",
          "main": "index.js",
          "scripts": {
            "start": "node index.js"
          },
          "dependencies": {
            "express": "^4.18.1"
          }
        }
        EOF
        
        # Create a simple index.js
        cat > index.js << 'EOF'
        const express = require('express');
        const app = express();
        const port = 3000;
        
        app.get('/', (req, res) => {
          res.send('Hello World!');
        });
        
        app.listen(port, () => {
          console.log(`Server running on port ${port}`);
        });
        EOF
        
        # Use the actual Dockerfile template from the extension (simplified for testing)
        # Extract the key parts we want to test
        cat > Dockerfile.test << 'DOCKERFILE_EOF'
        FROM container-registry.oracle.com/os/oraclelinux:8-slim AS builder
        
        ARG NODE_VERSION=20
        RUN microdnf install -y nodejs npm && \
            microdnf clean all
        
        WORKDIR /app
        
        # Copy package files
        COPY package*.json ./
        
        # Remove package-lock.json if it exists
        RUN rm -f package-lock.json || true
        
        # Validate and fix package.json if needed
        RUN node -e " \
          try { \
            const fs = require('fs'); \
            const pkgPath = 'package.json'; \
            if (!fs.existsSync(pkgPath)) { \
              console.error('package.json not found'); \
              process.exit(1); \
            } \
            const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8')); \
            if (pkg.name) { \
              const oldName = pkg.name; \
              const isValid = /^[a-z0-9._-]+$/.test(pkg.name.toLowerCase()); \
              if (!isValid) { \
                pkg.name = pkg.name.toLowerCase() \
                  .replace(/[^a-z0-9._-]/g, '-') \
                  .replace(/^-+|-+$/g, '') \
                  .replace(/\.{2,}/g, '.') \
                  .substring(0, 214); \
                if (!pkg.name) pkg.name = 'app'; \
                console.log('Fixed invalid package name: \"' + oldName + '\" -> \"' + pkg.name + '\"'); \
                fs.writeFileSync(pkgPath, JSON.stringify(pkg, null, 2) + '\n'); \
              } \
            } \
          } catch (e) { \
            console.error('Error fixing package.json:', e.message); \
            process.exit(1); \
          } \
        "
        
        # Install dependencies
        RUN npm install --no-audit --no-fund
        
        # Copy application files
        COPY . .
        
        # Fix package.json again in case COPY overwrote it
        RUN node -e " \
          try { \
            const fs = require('fs'); \
            const pkgPath = 'package.json'; \
            if (fs.existsSync(pkgPath)) { \
              const pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8')); \
              if (pkg.name) { \
                const oldName = pkg.name; \
                const isValid = /^[a-z0-9._-]+$/.test(pkg.name.toLowerCase()); \
                if (!isValid) { \
                  pkg.name = pkg.name.toLowerCase() \
                    .replace(/[^a-z0-9._-]/g, '-') \
                    .replace(/^-+|-+$/g, '') \
                    .replace(/\.{2,}/g, '.') \
                    .substring(0, 214); \
                  if (!pkg.name) pkg.name = 'app'; \
                  console.log('Fixed invalid package name after COPY: \"' + oldName + '\" -> \"' + pkg.name + '\"'); \
                  fs.writeFileSync(pkgPath, JSON.stringify(pkg, null, 2) + '\n'); \
                } \
              } \
            } \
          } catch (e) { \
            console.error('Error fixing package.json after COPY:', e.message); \
            process.exit(1); \
          } \
        "
        
        # Build application (only if build script exists)
        RUN HAS_BUILD=$(node -p "try{require('./package.json').scripts.build?'yes':'no'}catch(e){'no'}") && \
            if [ "$HAS_BUILD" = "yes" ]; then \
              echo "Build script found, running npm run build"; \
              npm run build; \
            else \
              echo "No build script found in package.json, skipping build step"; \
            fi
        
        # Runtime stage
        FROM container-registry.oracle.com/os/oraclelinux:8-slim
        
        ARG NODE_VERSION=20
        RUN microdnf install -y nodejs npm && \
            microdnf clean all
        
        WORKDIR /app
        
        # Copy package files from builder stage
        COPY --from=builder /app/package*.json ./
        
        # Install production dependencies only
        RUN npm install --production --no-audit --no-fund
        
        # Copy built application from builder stage
        COPY --from=builder /app ./
        
        EXPOSE 3000
        
        # Use the same start script approach as the actual template
        ENV NODE_ENTRY_POINT=index.js
        RUN echo '#!/bin/sh' > /app/start.sh && \
            echo 'if [ -f package.json ]; then' >> /app/start.sh && \
            echo '  HAS_START=$(node -p "try{require(\"./package.json\").scripts.start?\"yes\":\"no\"}catch(e){\"no\"}")' >> /app/start.sh && \
            echo '  if [ "$HAS_START" = "yes" ]; then' >> /app/start.sh && \
            echo '    npm start' >> /app/start.sh && \
            echo '  else' >> /app/start.sh && \
            echo '    node "$NODE_ENTRY_POINT"' >> /app/start.sh && \
            echo '  fi' >> /app/start.sh && \
            echo 'else' >> /app/start.sh && \
            echo '  node "$NODE_ENTRY_POINT"' >> /app/start.sh && \
            echo 'fi' >> /app/start.sh && \
            chmod +x /app/start.sh
        
        CMD ["/app/start.sh"]
        DOCKERFILE_EOF
        
        # Test Docker build
        echo "Testing Docker build with invalid package name..."
        docker build -f Dockerfile.test -t test-nodejs-app:latest . 2>&1 | tee /tmp/docker-build.log
        
        # Verify the image was created
        if docker images | grep -q test-nodejs-app; then
          echo "âœ… Docker build test passed - image created successfully"
          docker images | grep test-nodejs-app
        else
          echo "âŒ Docker build test failed - image not created"
          cat /tmp/docker-build.log
          exit 1
        fi
        
        # Verify package name was fixed in the build log
        if grep -q "Fixed invalid package name" /tmp/docker-build.log; then
          echo "âœ… Package name fix verified in build log"
        else
          echo "âš ï¸  Package name fix not found in build log (may not have been needed)"
        fi
        
        echo "Docker build test completed successfully"

    - name: Test Docker image runtime
      run: |
        cd /tmp/test-nodejs-app
        
        # Test that the container starts and responds
        echo "Testing Docker container runtime..."
        
        # Start container in background
        CONTAINER_ID=$(docker run -d -p 3000:3000 test-nodejs-app:latest)
        echo "Container ID: $CONTAINER_ID"
        
        # Show container status immediately
        echo "Container status:"
        docker ps -a | grep "$CONTAINER_ID" || docker ps -a
        
        # Wait for container to start and show logs
        echo "Waiting for container to start..."
        sleep 3
        
        # Show container logs
        echo "Container logs:"
        docker logs "$CONTAINER_ID" || true
        
        # Check container status more reliably
        CONTAINER_STATUS=$(docker inspect -f '{{.State.Status}}' "$CONTAINER_ID" 2>/dev/null || echo "unknown")
        echo "Container status: $CONTAINER_STATUS"
        
        if [ "$CONTAINER_STATUS" != "running" ]; then
          echo "âŒ Container is not running (status: $CONTAINER_STATUS)"
          echo "Full container logs:"
          docker logs "$CONTAINER_ID" || true
          echo "Container details:"
          docker inspect "$CONTAINER_ID" || true
          docker rm "$CONTAINER_ID" || true
          exit 1
        fi
        
        # Wait a bit more for the app to be ready
        sleep 2
        
        # Test HTTP endpoint
        echo "Testing HTTP endpoint..."
        HTTP_SUCCESS=false
        for i in {1..15}; do
          if curl -f -s http://localhost:3000/ >/dev/null 2>&1; then
            echo "âœ… Container is responding to HTTP requests (attempt $i)"
            RESPONSE=$(curl -s http://localhost:3000/)
            if echo "$RESPONSE" | grep -q "Hello World"; then
              echo "âœ… Container returned expected response: $RESPONSE"
              HTTP_SUCCESS=true
              break
            else
              echo "âš ï¸  Unexpected response: $RESPONSE"
            fi
          else
            echo "Waiting for HTTP endpoint... (attempt $i/15)"
          fi
          sleep 2
        done
        
        if [ "$HTTP_SUCCESS" != "true" ]; then
          echo "âŒ Container did not respond to HTTP requests after 15 attempts"
          echo "Container logs:"
          docker logs "$CONTAINER_ID" || true
          echo "Container status:"
          docker ps -a | grep "$CONTAINER_ID" || docker ps -a
          docker stop "$CONTAINER_ID" || true
          docker rm "$CONTAINER_ID" || true
          exit 1
        fi
        
        # Stop and remove container
        echo "Stopping container..."
        docker stop "$CONTAINER_ID" || true
        docker rm "$CONTAINER_ID" || true
        
        echo "âœ… Docker runtime test completed successfully"

    - name: Upload VSIX artifact
      uses: actions/upload-artifact@v4
      with:
        name: oci-devops-vsix
        path: oci-devops/oci-devops-*.vsix
        retention-days: 30

    - name: Note about VSIX file
      if: (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/master') && github.event_name == 'push'
      run: |
        echo "â„¹ï¸  VSIX file is available as a downloadable artifact"
        echo "â„¹ï¸  VSIX files are ignored by .gitignore and are not committed to the repository"
        echo "â„¹ï¸  Download the VSIX from the workflow artifacts if needed"

    - name: Summary
      run: |
        echo "## Build Summary" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… VSIX extension built successfully" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… Docker build test passed" >> $GITHUB_STEP_SUMMARY
        echo "- âœ… Docker runtime test passed" >> $GITHUB_STEP_SUMMARY
        if [ -f oci-devops/oci-devops-*.vsix ]; then
          VSIX_SIZE=$(ls -lh oci-devops/oci-devops-*.vsix | awk '{print $5}')
          echo "- ðŸ“¦ VSIX size: $VSIX_SIZE" >> $GITHUB_STEP_SUMMARY
        fi
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "**Note:** VSIX files are available as downloadable artifacts and are not committed to the repository (ignored by .gitignore)"
